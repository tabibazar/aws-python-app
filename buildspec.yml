version: 0.2

env:
  git-credential-helper: yes
  variables:
    ECR_URI: '502768277707.dkr.ecr.ca-central-1.amazonaws.com/aws_python_app'
    AWS_REGION: 'ca-central-1'
    AWS_DEFAULT_REGION: 'ca-central-1'
    EKS_CLUSTER_NAME: 'extravagant-folk-walrus'
    K8S_NAMESPACE: 'default'
    K8S_DEPLOYMENT_NAME: 'flask-app'
    K8S_CONTAINER_NAME: 'flask-app'
    APP_PORT: '8000'
    SVC_PORT: '80'

phases:
  install:
    commands:
      - 'echo Installing kubectl and tools'
      - 'apt-get update -y'
      - 'apt-get install -y jq gettext-base curl'
      - 'curl -L -o /usr/local/bin/kubectl "https://dl.k8s.io/release/$(curl -Ls https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"'
      - 'chmod +x /usr/local/bin/kubectl'
      - 'echo Starting Docker daemon'
      - 'nohup /usr/local/bin/dockerd-entrypoint.sh >/tmp/dockerd.log 2>&1 &'
      - 'timeout 60 sh -c '\''until docker info >/dev/null 2>&1; do echo Waiting for Docker; sleep 2; done'\'''
      - 'docker version'

  pre_build:
    commands:
      - 'echo Login to ECR'
      - 'REGISTRY_HOST=$(echo "${ECR_URI}" | cut -d"/" -f1)'
      - 'aws ecr get-login-password --region "${AWS_REGION}" | docker login --username AWS --password-stdin "${REGISTRY_HOST}"'

  build:
    commands:
      - 'echo Build and tag :latest'
      - 'docker build -t "${ECR_URI}:latest" .'

  post_build:
    commands:
      - 'echo Push image'
      - 'docker push "${ECR_URI}:latest"'
      - 'printf "{\"image\":\"%s\"}\n" "${ECR_URI}:latest" > image.json'

      - 'echo Configure kubeconfig'
      - 'export KUBECONFIG=/root/.kube/config'
      - 'aws sts get-caller-identity'
      - 'aws eks describe-cluster --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}"'
      - 'aws eks update-kubeconfig --name "${EKS_CLUSTER_NAME}" --region "${AWS_REGION}"'

      # ---- Imperative deploy (no manifests) ----
      - 'echo Ensure Deployment exists'
      - 'kubectl get deploy "${K8S_DEPLOYMENT_NAME}" -n "${K8S_NAMESPACE}" || kubectl create deployment "${K8S_DEPLOYMENT_NAME}" --image="${ECR_URI}:latest" -n "${K8S_NAMESPACE}"'
      - 'kubectl set image deployment/"${K8S_DEPLOYMENT_NAME}" "${K8S_CONTAINER_NAME}=${ECR_URI}:latest" -n "${K8S_NAMESPACE}"'
      - 'kubectl set env deployment/"${K8S_DEPLOYMENT_NAME}" FLASK_ENV=production -n "${K8S_NAMESPACE}"'
      - 'kubectl set resources deployment/"${K8S_DEPLOYMENT_NAME}" --requests=cpu=100m,memory=128Mi --limits=cpu=500m,memory=512Mi -n "${K8S_NAMESPACE}"'
      - 'kubectl patch deployment "${K8S_DEPLOYMENT_NAME}" -n "${K8S_NAMESPACE}" --type=json -p='"'"'[{"op":"add","path":"/spec/template/spec/containers/0/ports","value":[{"containerPort":'"${APP_PORT}"'}]}]'"'"' || true'
      - 'kubectl patch deployment "${K8S_DEPLOYMENT_NAME}" -n "${K8S_NAMESPACE}" --type=json -p='"'"'[{"op":"add","path":"/spec/template/spec/containers/0/imagePullPolicy","value":"Always"}]'"'"' || true'

      - 'echo Ensure LoadBalancer Service exists'
      - 'kubectl get svc "${K8S_DEPLOYMENT_NAME}" -n "${K8S_NAMESPACE}" || kubectl expose deployment "${K8S_DEPLOYMENT_NAME}" --type=LoadBalancer --name="${K8S_DEPLOYMENT_NAME}" --port="${SVC_PORT}" --target-port="${APP_PORT}" -n "${K8S_NAMESPACE}"'

      - 'echo Wait for rollout'
      - 'kubectl rollout status deployment/"${K8S_DEPLOYMENT_NAME}" -n "${K8S_NAMESPACE}" --timeout=5m'

      - 'echo Fetch LoadBalancer address'
      - 'for i in $(seq 1 30); do H=$(kubectl get svc "${K8S_DEPLOYMENT_NAME}" -n "${K8S_NAMESPACE}" -o jsonpath="{.status.loadBalancer.ingress[0].hostname}"); IP=$(kubectl get svc "${K8S_DEPLOYMENT_NAME}" -n "${K8S_NAMESPACE}" -o jsonpath="{.status.loadBalancer.ingress[0].ip}"); if [ -n "$H$IP" ]; then echo "Service URL: http://${H:-$IP}"; break; fi; echo "Waiting for EXTERNAL-IP..."; sleep 10; done'

artifacts:
  files:
    - image.json
  discard-paths: yes